<p align='center'>
<a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a>
<a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a>
<a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a>


# 深入理解操作系统 第七章

>   第七章的主要内容是：进程

## 进程(process)描述

### 进程定义

进程 : 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.

### 进程的组成

进程包括 :

-   程序的代码
-   程序处理的数据
-   程序计数器中的值, 指示下一条将运行的指令
-   一组通用的寄存器的当前值, 堆, 栈
-   一组系统资源(如打开的文件)

进程和程序的联系 :

-   程序是产生进程的基础
-   程序的每次运行构成不同的进程
-   进程是程序功能的体现
-   通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.

进程和程序的区别 :

-   进程是动态的,  程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 / 用户态.
-   进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.
-   进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块(进程状态信息)

### 进程的特点

**动态性** : 可动态地创建, 结果进程;

**并发性** : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻)

**独立性** : 不同进程的工作不相互影响;(页表是保障措施之一)

**制约性** : 因访问共享数据, 资源或进程间同步而产生制约.

>   抛出了一个问题 : 如果你要设计一个OS, 怎么样来实现其中的进程管理机制?
>

### 进程控制结构

描述进程的数据结构 : 进程控制块 (Process Control Block)

操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息.

**进程控制块 :** 操作系统管理控制进程运行所用的信息集合.

进程的创建 : 为该进程生成一个PCB

**进程的终止 :** 回收它的PCB

**进程的组织管理 :** 通过对PCB的组织管理来实现

(PCB具体包含什么信息? 如何组织的? 进程的状态转换?)

**PCB有以下三大类信息 :**

-   进程标志信息. 如本进程的标志, 本进程的产生者标志(父进程标志). 用户标志
-   处理机状态信息保存区 : 保存进程的运行现场信息 :
    -   用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器
    -   控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)
    -   栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它
-   进程控制信息
    -   调度和状态信息. 用于操作系统调度进程并占用处理机使用.
    -   进程间通信信息. 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.
    -   存储管理信息. 包含有指向本进程映像存储空间的数据结构.
    -   进程所用资源. 说明由进程打开, 使用的系统资源. 如打开的文件等.
    -   有关数据结构的链接信息. 进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB.

**进程的组织方式**

链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)

索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)

## 进程状态(state)

### 进程的生命期管理

#### 进程创建

引起进程创建的3个主要事件 :

-   系统初始化;
-   用户请求创建一个新进程;
-   正在运行的进程执行了创建进程的系统调用.

#### 进程运行

内核选择一个就绪的进程, 让它占用处理机并执行

(为何选择?如何选择?)

#### 进程等待(阻塞)

在以下情况下, 进程等待(阻塞):

1.  请求并等待系统服务, 无法马上完成
2.  启动某种操作, 无法马上完成
3.  需要的数据没有到达

进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.

#### 进程唤醒

唤醒进程的原因 :

1.  被阻塞进程需要的资源可被满足
2.  被阻塞进程等待的事件到达
3.  将该进程的PCB插入到就绪队列

进程只能被别的进程或操作系统唤醒

#### 进程结束

在以下四种情况下, 进程结束 :

-   正常退出(自愿)
-   错误退出(自愿)
-   致命错误(强制性)
-   被其他进程杀死(强制性)

### 进程状态变化模型

**进程的三种基本状态 :** 进程在生命结束前处于三种基本状态之一.

不同系统设置的进程状态数目不同.

**三种基本状态**

1.  运行状态(Running) : 当一个进程正在处理机上运行时
2.  就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行
3.  等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入/输出完成.

**进程其它的基本状态**

创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态

结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.

**可能的状态变化如下 :**

NULL → New : 一个新进程被产生出来执行一个程序

New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态

Ready → Running  : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行

Running → Exit   : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理

Running → Ready  : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机

Running → Blocked: 当进程请求某样东西且必须等待时

Blocked → Ready  : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态

### 进程挂起

进程挂起, 为了合理且充分地利用系统资源.

进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上.(把进程放到磁盘上)

**两种挂起状态**

1.  阻塞挂起状态 : 进程在外存并等待某事件的出现;
2.  就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.

**与挂起相关的状态转换**

**挂起 :** 把一个进程从内存转到外存, 可能有以下几种情况 :

-   阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.
-   就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.
-   运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.

**在外存时的状态转换 :**

-   阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.

**解挂, 激活 :** 把一个进程从外存转到内存; 可能有以下几种情况 :

-   就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.
-   阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.

>   抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程?
>

### 状态队列

-   由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;
-   不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列);
-   每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列.